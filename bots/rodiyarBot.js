import {Telegraf} from 'telegraf';
import axios from 'axios';
import cron from 'node-cron';
import fs from 'fs';
import path from 'path';
import {fileURLToPath} from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const STATUS_FILE = path.join(__dirname, 'statuses.json');
const SUBSCRIBERS_FILE = path.join(__dirname, 'subscribers.json');

const BOT_TOKEN = process.env.RODIYAR_BOT_TOKEN;
if (!BOT_TOKEN) {
  console.error('‚ùå –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è RODIYAR_BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω–∞!');
  process.exit(1);
}

const SITES = [
  {name: 'Patriot-CL.Ru', url: 'https://patriot-cl.ru/'},
  {name: 'Shvey-Dom.Ru', url: 'https://shvey-dom.ru/'},
  {name: 'RodiyarTech.Ru', url: 'https://rodiyartech.ru/'},
  {name: 'SNB.Group', url: 'https://snb.group/'},
  {name: 'Rodiyar.Tech', url: 'https://rodiyar.tech/'},
  {name: 'Ohrana-Objective.Ru', url: 'https://ohrana-objective.ru/'},
];

SITES.forEach((site) => {
  site.url = site.url.trim();
});

const BOT = new Telegraf(BOT_TOKEN);

BOT.use((ctx, next) => {
  if (ctx.message?.text) {
    const senderId = ctx.from?.id ?? 'unknown';
    const chatId = ctx.chat?.id ?? 'unknown';
    const username = ctx.from?.username ? `@${ctx.from.username}` : '';
    const fullName = ctx.from?.first_name || ctx.from?.last_name ?
        `${ctx.from.first_name || ''} ${ctx.from.last_name || ''}`.trim() :
        'no name';

    console.log(
        `[üì© –í—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ] –û—Ç: ID=${senderId} ${username} (${fullName}) | –ß–∞—Ç: ${chatId} | –¢–µ–∫—Å—Ç: "${ctx.message.text}"`,
    );
  }
  return next();
});

const loadSubscribers = () => {
  if (!fs.existsSync(SUBSCRIBERS_FILE)) {
    fs.writeFileSync(SUBSCRIBERS_FILE, JSON.stringify({}));
    return {};
  }
  try {
    return JSON.parse(fs.readFileSync(SUBSCRIBERS_FILE, 'utf8'));
  } catch (e) {
    console.error('‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è subscribers.json, —Å–æ–∑–¥–∞—ë–º –∑–∞–Ω–æ–≤–æ');
    fs.writeFileSync(SUBSCRIBERS_FILE, JSON.stringify({}));
    return {};
  }
};

const saveSubscribers = (subscribers) => {
  fs.writeFileSync(SUBSCRIBERS_FILE, JSON.stringify(subscribers, null, 2));
};

const getSubscriberIds = () => {
  const subs = loadSubscribers();
  return Object.keys(subs).map(Number);
};

const loadStatuses = () => {
  if (!fs.existsSync(STATUS_FILE)) {
    const initial = {};
    SITES.forEach((site) => initial[site.url] = true);
    fs.writeFileSync(STATUS_FILE, JSON.stringify(initial, null, 2));
    return initial;
  }
  try {
    return JSON.parse(fs.readFileSync(STATUS_FILE, 'utf8'));
  } catch (e) {
    console.error('‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è statuses.json, —Å–æ–∑–¥–∞—ë–º –∑–∞–Ω–æ–≤–æ');
    const initial = {};
    SITES.forEach((site) => initial[site.url] = true);
    fs.writeFileSync(STATUS_FILE, JSON.stringify(initial, null, 2));
    return initial;
  }
};

const saveStatuses = (statuses) => {
  fs.writeFileSync(STATUS_FILE, JSON.stringify(statuses, null, 2));
};

const getErrorDescription = (code) => {
  if (typeof code === 'number') {
    if (code === 400) return '–Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å (400)';
    if (code === 401) return '–Ω–µ–∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω (401)';
    if (code === 403) return '–¥–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω (403)';
    if (code === 404) return '—Å—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ (404)';
    if (code === 408) return '—Ç–∞–π–º–∞—É—Ç –∑–∞–ø—Ä–æ—Å–∞ (408)';
    if (code === 429) return '—Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤ (429)';
    if (code === 500) return '–≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ (500)';
    if (code === 502) return '–ø–ª–æ—Ö–æ–π —à–ª—é–∑ (502)';
    if (code === 503) return '—Å–µ—Ä–≤–∏—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (503)';
    if (code === 504) return '—à–ª—é–∑ –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –≤–æ–≤—Ä–µ–º—è (504)';
    if (code >= 400 && code < 500) return '–æ—à–∏–±–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞ (4xx)';
    if (code >= 500 && code < 600) return '–≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ (5xx)';
    return `–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π HTTP-—Å—Ç–∞—Ç—É—Å ${code}`;
  }

  switch (code) {
    case 'ENOTFOUND':
      return '–¥–æ–º–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω';
    case 'EAI_AGAIN':
      return '–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Å–±–æ–π DNS';
    case 'ECONNREFUSED':
      return '—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ';
    case 'ETIMEDOUT':
      return '—Ç–∞–π–º–∞—É—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è';
    case 'EHOSTUNREACH':
      return '—Ö–æ—Å—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω';
    case 'ENETUNREACH':
      return '—Å–µ—Ç—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞';
    case 'DEPTH_ZERO_SELF_SIGNED_CERT':
    case 'SELF_SIGNED_CERT_IN_CHAIN':
      return '—Å–∞–º–æ–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–π SSL-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç';
    case 'UNABLE_TO_VERIFY_LEAF_SIGNATURE':
      return '–Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å SSL-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç';
    case 'CERT_HAS_EXPIRED':
      return '—Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è SSL-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞ –∏—Å—Ç—ë–∫';
    case 'CERT_NOT_YET_VALID':
      return 'SSL-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç –µ—â—ë –Ω–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω';
    case 'ERR_TLS_CERT_ALTNAME_INVALID':
      return '–Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∏–º—è –≤ SSL-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–µ';
    case 'ERR_INVALID_URL':
      return '–Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π URL';
    case 'ERR_FR_TOO_MANY_REDIRECTS':
      return '—Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π';
    case 'ERR_NETWORK':
      return '—Å–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞';
    case 'ERR_BAD_RESPONSE':
      return '–Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞';
    default:
      return code ? `–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: ${code}` : '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞';
  }
};

const checkSite = async (site) => {
  try {
    const response = await axios.get(site.url, {
      timeout: 10_000,
      maxRedirects: 5,
      validateStatus: () => true, // –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –ø–æ —Å—Ç–∞—Ç—É—Å—É
    });

    const isOkStatus = response.status >= 200 && response.status < 400;
    const hasKeyword = response.data.includes(site.keyword);

    if (!isOkStatus) {
      throw {response};
    }
    if (!hasKeyword) {
      throw new Error('MISSING_KEYWORD');
    }

    return {
      ...site,
      ok: true,
      httpStatus: response.status,
      errorCode: String(response.status),
      description: '—Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ',
    };
  } catch (error) {
    let httpStatus = null;
    let errorCode = 'UNKNOWN';

    if (error.response?.status) {
      httpStatus = error.response.status;
      errorCode = String(httpStatus);
    } else if (error.code) {
      errorCode = error.code;
    } else if (error.message === 'MISSING_KEYWORD') {
      errorCode = 'MISSING_KEYWORD';
    }

    const description = errorCode === 'MISSING_KEYWORD' ?
        '–∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ' :
        getErrorDescription(errorCode);

    return {
      ...site,
      ok: false,
      httpStatus,
      errorCode,
      description,
    };
  }
};

const monitorSites = async () => {
  console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–∞–π—Ç–æ–≤...');

  const statuses = loadStatuses();
  const results = await Promise.all(SITES.map(checkSite));
  let hasChanges = false;

  for (const result of results) {
    const wasOk = statuses[result.url] === true;
    const nowOk = result.ok;

    if (wasOk && !nowOk) {
      const link = `<a href="${result.url}">${result.name}</a>`;
      const codePart = result.httpStatus ?
          `<b>${result.httpStatus} (${result.errorCode})</b>` :
          `<b>${result.errorCode}</b>`;
      const message = `üö® –°–∞–π—Ç —É–ø–∞–ª!\n\n‚Äî ${link}: ${codePart} ‚Äî ${result.description}`;

      const subscriberIds = getSubscriberIds();
      for (const id of subscriberIds) {
        try {
          await BOT.telegram.sendMessage(id, message, {
            parse_mode: 'HTML',
            disable_web_page_preview: true,
          });
        } catch (err) {
          console.error(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ ${id}:`, err.message);
        }
      }
      statuses[result.url] = false;
      hasChanges = true;
    } else if (!wasOk && nowOk) {
      const link = `<a href="${result.url}">${result.name}</a>`;
      const message = `‚úÖ –°–∞–π—Ç –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!\n\n‚Äî ${link} —Å–Ω–æ–≤–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç.`;

      const subscriberIds = getSubscriberIds();
      for (const id of subscriberIds) {
        try {
          await BOT.telegram.sendMessage(id, message, {
            parse_mode: 'HTML',
            disable_web_page_preview: true,
          });
        } catch (err) {
          console.error(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ ${id}:`, err.message);
        }
      }
      statuses[result.url] = true;
      hasChanges = true;
    }
  }

  if (hasChanges) {
    saveStatuses(statuses);
  }
};

BOT.start(async (ctx) => {
  const chatId = ctx.chat.id;
  const subscribers = loadSubscribers();

  if (ctx.chat.type === 'private') {
    const name = ctx.from?.first_name ?
        `${ctx.from.first_name} ${ctx.from.last_name || ''}`.trim() :
        `@${ctx.from?.username || 'unknown'}`;
    subscribers[chatId] = {type: 'private', name};
  } else {
    subscribers[chatId] = {
      type: ctx.chat.type,
      title: ctx.chat.title || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
    };
  }

  saveSubscribers(subscribers);

  const msg = `
ü§ñ <b>–ü—Ä–∏–≤–µ—Ç! –Ø ‚Äî –±–æ—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞</b>

–í—ã –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–∞–π—Ç–æ–≤:
‚Ä¢ Patriot-CL.Ru
‚Ä¢ Shvey-Dom.Ru
‚Ä¢ RodiyarTech.Ru
‚Ä¢ SNB.Group
‚Ä¢ Rodiyar.Tech
‚Ä¢ Ohrana-Objective.Ru

üîî –í—ã –ø–æ–ª—É—á–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:
‚Äî –µ—Å–ª–∏ —Å–∞–π—Ç —É–ø–∞–¥—ë—Ç (—Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑),
‚Äî –∫–æ–≥–¥–∞ –æ–Ω –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è.

üõ† –ö–æ–º–∞–Ω–¥—ã:
‚Ä¢ /status ‚Äî —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
‚Ä¢ /reload ‚Äî –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–µ–π—á–∞—Å
‚Ä¢ /stop ‚Äî –æ—Ç–ø–∏—Å–∞—Ç—å—Å—è`;
  return ctx.replyWithHTML(msg, {disable_web_page_preview: true});
});

BOT.command('stop', (ctx) => {
  const chatId = ctx.chat.id;
  const subscribers = loadSubscribers();
  if (subscribers[chatId]) {
    delete subscribers[chatId];
    saveSubscribers(subscribers);
    return ctx.reply('üîï –í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.');
  }
  return ctx.reply('–í—ã –Ω–µ –±—ã–ª–∏ –ø–æ–¥–ø–∏—Å–∞–Ω—ã.');
});

BOT.command('status', async (ctx) => {
  const results = await Promise.all(SITES.map(checkSite));
  const working = results.filter((r) => r.ok).length;
  const lines = results.map((r) => {
    const emoji = r.ok ? '‚úÖ' : '‚ùå';
    const link = `<a href="${r.url}">${r.name}</a>`;
    if (r.ok) {
      return `${emoji} ${link}`;
    } else {
      const codePart = r.httpStatus ?
          `${r.httpStatus} (${r.errorCode})` :
          r.errorCode;
      return `${emoji} ${link}: <b>${codePart}</b> ‚Äî ${r.description}`;
    }
  });
  const msg = `üìä –°–æ—Å—Ç–æ—è–Ω–∏–µ (${working}/${SITES.length} —Ä–∞–±–æ—Ç–∞—é—Ç):\n\n` + lines.join('\n');
  return ctx.replyWithHTML(msg, {disable_web_page_preview: true});
});

BOT.command('reload', async (ctx) => {
  await ctx.reply('üîÑ –ó–∞–ø—É—Å–∫–∞—é –ø—Ä–æ–≤–µ—Ä–∫—É...');
  const statusesBefore = loadStatuses();
  const results = await Promise.all(SITES.map(checkSite));
  const statusesAfter = {...statusesBefore};
  let hasChanges = false;

  for (const r of results) {
    const wasOk = statusesBefore[r.url] === true;
    const nowOk = r.ok;
    if (wasOk !== nowOk) {
      statusesAfter[r.url] = nowOk;
      hasChanges = true;
    }
  }

  if (hasChanges) {
    saveStatuses(statusesAfter);
  }

  const working = results.filter((r) => r.ok).length;
  const lines = results.map((r) => {
    const emoji = r.ok ? '‚úÖ' : '‚ùå';
    const link = `<a href="${r.url}">${r.name}</a>`;
    if (r.ok) {
      return `${emoji} ${link}`;
    } else {
      const codePart = r.httpStatus ?
          `${r.httpStatus} (${r.errorCode})` :
          r.errorCode;
      return `${emoji} ${link}: <b>${codePart}</b> ‚Äî ${r.description}`;
    }
  });
  const msg = `üìä –†—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ (${working}/${SITES.length}):\n\n` + lines.join('\n');
  return ctx.replyWithHTML(msg, {disable_web_page_preview: true});
});

BOT.on('message', (ctx) => {
  if (ctx.message?.new_chat_members?.some((user) => user.id === ctx.botInfo.id)) {
    const chatId = ctx.chat.id;
    const subscribers = loadSubscribers();
    subscribers[chatId] = {
      type: ctx.chat.type,
      title: ctx.chat.title || '–ù–æ–≤–∞—è –≥—Ä—É–ø–ø–∞',
    };
    saveSubscribers(subscribers);
    ctx.reply('‚úÖ –ë–æ—Ç –¥–æ–±–∞–≤–ª–µ–Ω! –ë—É–¥—É –ø—Ä–∏—Å—ã–ª–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–∞–π—Ç–æ–≤.')
        .catch(() => {
        });
  }
});

cron.schedule('*/5 * * * *', monitorSites);
monitorSites().catch(console.error);
BOT.launch().then(() => {
  console.log('üü¢ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ.');
});

process.once('SIGINT', () => BOT.stop('SIGINT'));
process.once('SIGTERM', () => BOT.stop('SIGTERM'));
